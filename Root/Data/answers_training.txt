Id|Body
35823399|"<p>Adding this answer for completeness, though it's only usable under certain conditions.</p>

<p>If you have very large lists, removing from the end of the list avoids CPython internals having to <code>memmove</code>, for situations where you can re-order the list. It gives a performance gain to remove from the end of the list, since it won't need to <code>memmove</code> <em>every</em> item after the one your removing - back one step <sup>(1)</sup>.<br>
For one-off removals the performance difference may be acceptable, but if you have a large list and need to remove many items - you will likely notice a performance hit.</p>

<p>Although admittedly, in these cases, doing a full list search is likely to be a performance bottleneck too, unless items are mostly at the front of the list.</p>

<p>This method can be used for more efficient removal,<br>as long as re-ordering the list is acceptable. <sup>(2)</sup></p>

<pre><code>def remove_unordered(ls, item):
    i = ls.index(item)
    ls[-1], ls[i] = ls[i], ls[-1]
    ls.pop()
</code></pre>

<p>You may want to avoid raising an error when the <code>item</code> isn't in the list.</p>

<pre><code>def remove_unordered_test(ls, item):
    try:
        i = ls.index(item)
    except ValueError:
        return False
    ls[-1], ls[i] = ls[i], ls[-1]
    ls.pop()
    return True
</code></pre>

<hr>

<ol>
<li>While I tested this with CPython, its quite likely most/all other Python implementations use an array to store lists internally. So unless they use a sophisticated data structure designed for efficient list re-sizing, they likely have the same performance characteristic.</li>
</ol>

<blockquote>
  <p>A simple way to test this, compare the speed difference from removing from the front of the list with removing the last element:</p>

<pre><code>python -m timeit 'a = [0] * 100000' 'while a: a.remove(0)'
</code></pre>
  
  <p>With:</p>

<pre><code>python -m timeit 'a = [0] * 100000' 'while a: a.pop()'
</code></pre>
  
  <p><em>(gives an order of magnitude speed difference where the second example is faster with CPython and PyPy).</em></p>
</blockquote>

<ol start=""2"">
<li>In this case you might consider using a <code>set</code>, especially if the list isn't meant to store duplicates.<br>In practice though you may need to store mutable data which can't be added to a <code>set</code>. Also check on btree's if the data can be ordered.</li>
</ol>
"
45074712|"<p>Python classes are themselves objects - as in instance - of their meta-class. </p>

<p>The default metaclass, which is applied when when you determine classes as:</p>

<pre><code>class foo:
    ...
</code></pre>

<p>meta class are used to apply some rule to an entire set of classes. For example, suppose you're building an ORM to access a database, and you want records from each table to be of a class mapped to that table (based on fields, business rules, etc..,), a possible use of metaclass is for instance, connection pool logic, which is share by all classes of record from all tables. Another use is logic to to support foreign keys, which involves multiple classes of records. </p>

<p>when you define metaclass, you subclass type, and can overrided the following magic methods to insert your logic. </p>

<pre><code>class somemeta(type):
    __new__(mcs, name, bases, clsdict):
      """"""
  mcs: is the base metaclass, in this case type.
  name: name of the new class, as provided by the user.
  bases: tuple of base classes 
  clsdict: a dictionary containing all methods and attributes defined on class

  you must return a class object by invoking the __new__ constructor on the base metaclass. 
 ie: 
    return type.__call__(mcs, name, bases, clsdict).

  in the following case:

  class foo(baseclass):
        __metaclass__ = somemeta

  an_attr = 12

  def bar(self):
      ...

  @classmethod
  def foo(cls):
      ...

      arguments would be : ( somemeta, ""foo"", (baseclass, baseofbase,..., object), {""an_attr"":12, ""bar"": &lt;function&gt;, ""foo"": &lt;bound class method&gt;}

      you can modify any of these values before passing on to type
      """"""
      return type.__call__(mcs, name, bases, clsdict)


    def __init__(self, name, bases, clsdict):
      """""" 
      called after type has been created. unlike in standard classes, __init__ method cannot modify the instance (cls) - and should be used for class validaton.
      """"""
      pass


    def __prepare__():
        """"""
        returns a dict or something that can be used as a namespace.
        the type will then attach methods and attributes from class definition to it.

        call order :

        somemeta.__new__ -&gt;  type.__new__ -&gt; type.__init__ -&gt; somemeta.__init__ 
        """"""
        return dict()

    def mymethod(cls):
        """""" works like a classmethod, but for class objects. Also, my method will not be visible to instances of cls.
        """"""
        pass
</code></pre>

<p>anyhow, those two are the most commonly used hooks. metaclassing is powerful, and above is nowhere near and exhaustive list of uses for metaclassing. </p>
"
13891070|"<p>The <a href=""https://docs.python.org/2/library/time.html#time.time"" rel=""noreferrer""><code>time.time()</code></a> function returns the number of seconds since the epoch as seconds in UTC.</p>

<p>Here is some sample output I ran on my computer, converting it to a string as well.</p>

<pre><code>Python 2.7.3 (default, Apr 24 2012, 00:00:54) 
[GCC 4.7.0 20120414 (prerelease)] on linux2
Type ""help"", ""copyright"", ""credits"" or ""license"" for more information.
&gt;&gt;&gt; import time
&gt;&gt;&gt; ts = time.time()
&gt;&gt;&gt; print ts
1355563265.81
&gt;&gt;&gt; import datetime
&gt;&gt;&gt; st = datetime.datetime.fromtimestamp(ts).strftime('%Y-%m-%d %H:%M:%S')
&gt;&gt;&gt; print st
2012-12-15 01:21:05
&gt;&gt;&gt;
</code></pre>

<p>The <code>ts</code> variable is the time returned in seconds.  I then converted it to a string using the <code>datetime</code> library making it a string that is human readable. </p>
"
37403193|"<p>Here's a fast generator that uses a dict to store each element as a key with a boolean value for checking if the duplicate item has already been yielded.</p>

<p>For lists with all elements that are hashable types:</p>

<pre><code>def gen_dupes(array):
    unique = {}
    for value in array:
        if value in unique and unique[value]:
            unique[value] = False
            yield value
        else:
            unique[value] = True

array = [1, 2, 2, 3, 4, 1, 5, 2, 6, 6]
print(list(gen_dupes(array)))
# =&gt; [2, 1, 6]
</code></pre>

<p>For lists that might contain lists:</p>

<pre><code>def gen_dupes(array):
    unique = {}
    for value in array:
        is_list = False
        if type(value) is list:
            value = tuple(value)
            is_list = True

        if value in unique and unique[value]:
            unique[value] = False
            if is_list:
                value = list(value)

            yield value
        else:
            unique[value] = True

array = [1, 2, 2, [1, 2], 3, 4, [1, 2], 5, 2, 6, 6]
print(list(gen_dupes(array)))
# =&gt; [2, [1, 2], 6]
</code></pre>
"
32555515|"<p>Below is a ""standard recursive answer"", similar to the other similar answer <a href=""https://stackoverflow.com/a/23743696/711085"">https://stackoverflow.com/a/23743696/711085</a> . (We don't realistically have to worry about running out of stack space since there's no way we could process all N! permutations.)</p>

<p>It visits every element in turn, and either takes it or leaves it (we can directly see the 2^N cardinality from this algorithm).</p>

<pre><code>def combs(xs, i=0):
    if i==len(xs):
        yield ()
        return
    for c in combs(xs,i+1):
        yield c
        yield c+(xs[i],)
</code></pre>

<hr>

<p>Demo:</p>

<pre><code>&gt;&gt;&gt; list( combs(range(5)) )
[(), (0,), (1,), (1, 0), (2,), (2, 0), (2, 1), (2, 1, 0), (3,), (3, 0), (3, 1), (3, 1, 0), (3, 2), (3, 2, 0), (3, 2, 1), (3, 2, 1, 0), (4,), (4, 0), (4, 1), (4, 1, 0), (4, 2), (4, 2, 0), (4, 2, 1), (4, 2, 1, 0), (4, 3), (4, 3, 0), (4, 3, 1), (4, 3, 1, 0), (4, 3, 2), (4, 3, 2, 0), (4, 3, 2, 1), (4, 3, 2, 1, 0)]

&gt;&gt;&gt; list(sorted( combs(range(5)), key=len))
[(), 
 (0,), (1,), (2,), (3,), (4,), 
 (1, 0), (2, 0), (2, 1), (3, 0), (3, 1), (3, 2), (4, 0), (4, 1), (4, 2), (4, 3), 
 (2, 1, 0), (3, 1, 0), (3, 2, 0), (3, 2, 1), (4, 1, 0), (4, 2, 0), (4, 2, 1), (4, 3, 0), (4, 3, 1), (4, 3, 2), 
 (3, 2, 1, 0), (4, 2, 1, 0), (4, 3, 1, 0), (4, 3, 2, 0), (4, 3, 2, 1), 
 (4, 3, 2, 1, 0)]

&gt;&gt;&gt; len(set(combs(range(5))))
32
</code></pre>
"
6347576|"<p>Here is a variant on <a href=""https://stackoverflow.com/questions/36932/whats-the-best-way-to-implement-an-enum-in-python/1695250#1695250"">Alec Thomas's solution</a>:</p>

<pre><code>def enum(*args, **kwargs):
    return type('Enum', (), dict((y, x) for x, y in enumerate(args), **kwargs)) 

x = enum('POOH', 'TIGGER', 'EEYORE', 'ROO', 'PIGLET', 'RABBIT', 'OWL')
assert x.POOH == 0
assert x.TIGGER == 1
</code></pre>
"
32649302|"<pre><code>from operator import truediv

c = truediv(a, b)
</code></pre>
"
35199035|"<p>Here is a tiny timer class that returns ""hh:mm:ss"" string: </p>

<pre><code>class Timer:
  def __init__(self):
    self.start = time.time()

  def restart(self):
    self.start = time.time()

  def get_time_hhmmss(self):
    end = time.time()
    m, s = divmod(end - self.start, 60)
    h, m = divmod(m, 60)
    time_str = ""%02d:%02d:%02d"" % (h, m, s)
    return time_str
</code></pre>

<p>Usage: </p>

<pre><code># Start timer
my_timer = Timer()

# ... do something

# Get time string:
time_hhmmss = my_timer.get_time_hhmmss()
print(""Time elapsed: %s"" % time_hhmmss )

# ... use the timer again
my_timer.restart()

# ... do something

# Get time:
time_hhmmss = my_timer.get_time_hhmmss()

# ... etc
</code></pre>
"
16637874|"<p>Just an FYI adding to Chris. B (best answer):</p>

<pre><code>d = defaultdict(int)
</code></pre>

<p>Works as well; the reason is that calling <code>int()</code> returns <code>0</code> which is what <code>defaultdict</code> does behind the scenes (when constructing a dictionary), hence the name ""Factory Function"" in the documentation.</p>
"
5574749|"<p>I would say that your first approach:</p>

<pre><code>print &gt;&gt; sys.stderr, 'spam' 
</code></pre>

<p>is the ""One . . . <strong>obvious</strong> way to do it""  The others don't satisfy rule #1 (""Beautiful is better than ugly."")</p>
"
8369232|"<pre><code>f = open('data.txt','r')
string = """"
while 1:
    line = f.readline()
    if not line:break
    string += line

f.close()


print string
</code></pre>
"
35041435|"<p><code>pip install -U setuptools</code> and <code>easy_install</code> was putting egg-info in the wrong directory.</p>

<p>Then I just reinstalled <code>apt-get install python-dev</code>.
Let me install the drivers I want after that</p>
"
1810760|"<p>Try <a href=""http://docs.python.org/library/os.html#os.chdir"" rel=""noreferrer""><code>os.chdir</code></a></p>

<blockquote>
<pre><code>os.chdir(path)
</code></pre>
  
  <p>        Change the current working directory to path. Availability: Unix, Windows.</p>
</blockquote>
"
1229342|"<p>Like other people have said, generally Python strings are supposed to be immutable.</p>

<p>However, if you are using CPython, the implementation at python.org, it is possible to use ctypes to modify the string structure in memory.</p>

<p>Here is an example where I use the technique to clear a string.</p>

<p><a href=""https://stackoverflow.com/questions/982682/mark-data-as-sensitive-in-python/983525#983525"">Mark data as sensitive in python</a></p>

<p>I mention this for the sake of completeness, and this should be your last resort as it is hackish.</p>
"
28576383|"<blockquote>
  <h1>How do I get the current time in Python?</h1>
</blockquote>

<h2>The <code>time</code> module</h2>

<p>The <code>time</code> module provides functions that tells us the time in ""seconds since the epoch"" as well as other utilities.</p>

<pre><code>import time
</code></pre>

<h3>Unix Epoch Time</h3>

<p>This is the format you should get timestamps in for saving in databases. It is a simple floating point number that can be converted to an integer. It is also good for arithmetic in seconds, as it represents the number of seconds since Jan 1, 1970 00:00:00, and it is memory light relative to the other representations of time we'll be looking at next:</p>

<pre><code>&gt;&gt;&gt; time.time()
1424233311.771502
</code></pre>

<p>This timestamp does not account for leap-seconds, so it's not linear - leap seconds are ignored. So while it is not equivalent to the international UTC standard, it is close, and therefore quite good for most cases of record-keeping. </p>

<p>This is not ideal for human scheduling, however. If you have a future event you wish to take place at a certain point in time, you'll want to store that time with a string that can be parsed into a datetime object or a serialized datetime object (these will be described later).</p>

<h3><code>time.ctime</code></h3>

<p>You can also represent the current time in the way preferred by your operating system (which means it can change when you change your system preferences, so don't rely on this to be standard across all systems, as I've seen others expect). This is typically user friendly, but doesn't typically result in strings one can sort chronologically:</p>

<pre><code>&gt;&gt;&gt; time.ctime()
'Tue Feb 17 23:21:56 2015'
</code></pre>

<p>You can hydrate timestamps into human readable form with <code>ctime</code> as well:</p>

<pre><code>&gt;&gt;&gt; time.ctime(1424233311.771502)
'Tue Feb 17 23:21:51 2015'
</code></pre>

<p>This conversion is also not good for record-keeping (except in text that will only be parsed by humans - and with improved Optical Character Recognition and Artificial Intelligence, I think the number of these cases will diminish).</p>

<h2><code>datetime</code> module</h2>

<p>The <code>datetime</code> module is also quite useful here:</p>

<pre><code>&gt;&gt;&gt; import datetime
</code></pre>

<h3><code>datetime.datetime.now</code></h3>

<p>The <code>datetime.now</code> is a class method that returns the current time. It uses the <code>time.localtime</code> without the timezone info (if not given, otherwise see timezone aware below). It has a representation (which would allow you to recreate an equivalent object) echoed on the shell, but when printed (or coerced to a <code>str</code>), it is in human readable (and nearly ISO) format, and the lexicographic sort is equivalent to the chronological sort:</p>

<pre><code>&gt;&gt;&gt; datetime.datetime.now()
datetime.datetime(2015, 2, 17, 23, 43, 49, 94252)
&gt;&gt;&gt; print(datetime.datetime.now())
2015-02-17 23:43:51.782461
</code></pre>

<h3>datetime's <code>utcnow</code></h3>

<p>You can get a datetime object in UTC time, a global standard, by doing this:</p>

<pre><code>&gt;&gt;&gt; datetime.datetime.utcnow()
datetime.datetime(2015, 2, 18, 4, 53, 28, 394163)
&gt;&gt;&gt; print(datetime.datetime.utcnow())
2015-02-18 04:53:31.783988
</code></pre>

<p>UTC is a time standard that is nearly equivalent to the GMT timezone. (While GMT and UTC do not change for Daylight Savings Time, their users may switch to other timezones, like British Summer Time, during the Summer.) </p>

<h3>datetime timezone aware</h3>

<p>However, none of the datetime objects we've created so far can be easily converted to various timezones. We can solve that problem with the <code>pytz</code> module:</p>

<pre><code>&gt;&gt;&gt; import pytz
&gt;&gt;&gt; then = datetime.datetime.now(pytz.utc)
&gt;&gt;&gt; then
datetime.datetime(2015, 2, 18, 4, 55, 58, 753949, tzinfo=&lt;UTC&gt;)
</code></pre>

<p>Equivalently, in Python 3 we have the <code>timezone</code> class with a utc <code>timezone</code> instance attached, which also makes the object timezone aware (but to convert to another timezone without the handy <code>pytz</code> module is left as an exercise to the reader):</p>

<pre><code>&gt;&gt;&gt; datetime.datetime.now(datetime.timezone.utc)
datetime.datetime(2015, 2, 18, 22, 31, 56, 564191, tzinfo=datetime.timezone.utc)
</code></pre>

<p>And we see we can easily convert to timezones from the original utc object.</p>

<pre><code>&gt;&gt;&gt; print(then)
2015-02-18 04:55:58.753949+00:00
&gt;&gt;&gt; print(then.astimezone(pytz.timezone('US/Eastern')))
2015-02-17 23:55:58.753949-05:00
</code></pre>

<p>You can also make a naive datetime object aware with the <code>pytz</code> timezone <code>localize</code> method, or by replacing the tzinfo attribute (with <code>replace</code>, this is done blindly), but these are more last resorts than best practices:</p>

<pre><code>&gt;&gt;&gt; pytz.utc.localize(datetime.datetime.utcnow())
datetime.datetime(2015, 2, 18, 6, 6, 29, 32285, tzinfo=&lt;UTC&gt;)
&gt;&gt;&gt; datetime.datetime.utcnow().replace(tzinfo=pytz.utc)
datetime.datetime(2015, 2, 18, 6, 9, 30, 728550, tzinfo=&lt;UTC&gt;)
</code></pre>

<p>The <code>pytz</code> module allows us to make our <code>datetime</code> objects timezone aware and convert the times to the hundreds of timezones available in the <code>pytz</code> module.</p>

<p>One could ostensibly serialize this object for UTC time and store <em>that</em> in a database, but it would require far more memory and be more prone to error than simply storing the Unix Epoch time, which I demonstrated first. </p>

<p>The other ways of viewing times are much more error prone, especially when dealing with data that may come from different time zones. You want there to be no confusion as to which timezone a string or serialized datetime object was intended for.</p>

<p>If you're displaying the time with Python for the user, <code>ctime</code> works nicely, not in a table (it doesn't typically sort well), but perhaps in a clock. However, I personally recommend, when dealing with time in Python, either using Unix time, or a timezone aware UTC <code>datetime</code> object. </p>
"
1207460|"<p>Your best approach for such an example would be a <a href=""http://docs.python.org/tutorial/datastructures.html#list-comprehensions"" rel=""noreferrer"">list comprehension</a></p>

<pre><code>somelist = [tup for tup in somelist if determine(tup)]
</code></pre>

<p>In cases where you're doing something more complex than calling a <code>determine</code> function, I prefer constructing a new list and simply appending to it as I go.  For example</p>

<pre><code>newlist = []
for tup in somelist:
    # lots of code here, possibly setting things up for calling determine
    if determine(tup):
        newlist.append(tup)
somelist = newlist
</code></pre>

<p>Copying the list using <code>remove</code> might make your code look a little cleaner, as described in one of the answers below.  You should definitely not do this for extremely large lists, since this involves first copying the entire list, and also performing an <code>O(n)</code> <code>remove</code> operation for each element being removed, making this an <code>O(n^2)</code> algorithm.</p>

<pre><code>for tup in somelist[:]:
    # lots of code here, possibly setting things up for calling determine
    if determine(tup):
        newlist.append(tup)
</code></pre>
"
326279|"<p>Note that rstrip doesn't act exactly like Perl's chomp() because it doesn't modify the string. That is, in Perl:</p>

<pre><code>$x=""a\n"";

chomp $x
</code></pre>

<p>results in <code>$x</code> being <code>""a""</code>.</p>

<p>but in Python:</p>

<pre><code>x=""a\n""

x.rstrip()
</code></pre>

<p>will mean that the value of <code>x</code> is <strong>still</strong> <code>""a\n""</code>. Even <code>x=x.rstrip()</code> doesn't always give the same result, as it strips all whitespace from the end of the string, not just one newline at most.</p>
"
17016257|"<p><strong>Edit 2016</strong></p>

<p>As Raymond <a href=""https://stackoverflow.com/a/39835527/336527"">pointed out</a>, in python 3.5+ where <code>OrderedDict</code> is implemented in C, the list comprehension approach will be slower than <code>OrderedDict</code> (unless you actually need the list at the end - and even then, only if the input is very short). So the best solution for 3.5+ is <code>OrderedDict</code>.</p>

<p><strong>Important Edit 2015</strong></p>

<p>As <a href=""https://stackoverflow.com/a/19279812/1219006"">@abarnert</a> notes, the <a href=""https://pythonhosted.org/more-itertools/api.html"" rel=""noreferrer""><code>more_itertools</code></a> library (<code>pip install more_itertools</code>) contains a <a href=""https://pythonhosted.org/more-itertools/api.html#more_itertools.unique_everseen"" rel=""noreferrer""><code>unique_everseen</code></a> function that is built to solve this problem without any <strong>unreadable</strong> (<code>not seen.add</code>) <strong>mutations</strong> in list comprehensions. This is also the fastest solution too:</p>

<pre><code>&gt;&gt;&gt; from  more_itertools import unique_everseen
&gt;&gt;&gt; items = [1, 2, 0, 1, 3, 2]
&gt;&gt;&gt; list(unique_everseen(items))
[1, 2, 0, 3]
</code></pre>

<p>Just one simple library import and no hacks. 
This comes from an implementation of the itertools recipe <a href=""https://docs.python.org/3/library/itertools.html#itertools-recipes"" rel=""noreferrer""><code>unique_everseen</code></a> which looks like:</p>

<pre><code>def unique_everseen(iterable, key=None):
    ""List unique elements, preserving order. Remember all elements ever seen.""
    # unique_everseen('AAAABBBCCDAABBB') --&gt; A B C D
    # unique_everseen('ABBCcAD', str.lower) --&gt; A B C D
    seen = set()
    seen_add = seen.add
    if key is None:
        for element in filterfalse(seen.__contains__, iterable):
            seen_add(element)
            yield element
    else:
        for element in iterable:
            k = key(element)
            if k not in seen:
                seen_add(k)
                yield element
</code></pre>

<hr>

<p>In Python <code>2.7+</code> the <strike>accepted common idiom</strike> (this works but isn't optimized for speed, i would now use <a href=""https://pythonhosted.org/more-itertools/api.html#more_itertools.unique_everseen"" rel=""noreferrer""><code>unique_everseen</code></a>) for this uses <a href=""http://docs.python.org/3/library/collections.html#collections.OrderedDict"" rel=""noreferrer""><code>collections.OrderedDict</code></a>:</p>

<p>Runtime: <strong>O(N)</strong></p>

<pre><code>&gt;&gt;&gt; from collections import OrderedDict
&gt;&gt;&gt; items = [1, 2, 0, 1, 3, 2]
&gt;&gt;&gt; list(OrderedDict.fromkeys(items))
[1, 2, 0, 3]
</code></pre>

<p>This looks much nicer than:</p>

<pre><code>seen = set()
[x for x in seq if x not in seen and not seen.add(x)]
</code></pre>

<p>and doesn't utilize the <strong>ugly hack</strong>:</p>

<pre><code>not seen.add(x)
</code></pre>

<p>which relies on the fact that <code>set.add</code> is an in-place method that always returns <code>None</code> so <code>not None</code> evaluates to <code>True</code>. </p>

<p>Note however that the hack solution is faster in raw speed though it has the same runtime complexity O(N).</p>
"
9847269|"<p>Use <code>weekday()</code> (<a href=""http://docs.python.org/library/datetime.html#datetime.date.weekday"">docs</a>):</p>

<pre><code>&gt;&gt;&gt; import datetime
&gt;&gt;&gt; datetime.datetime.today()
datetime.datetime(2012, 3, 23, 23, 24, 55, 173504)
&gt;&gt;&gt; datetime.datetime.today().weekday()
4
</code></pre>

<p>From the documentation:</p>

<blockquote>
  <p>Return the day of the week as an integer, where Monday is 0 and Sunday is 6.</p>
</blockquote>
"
36096474|"<p>Install prerequisites.</p>

<pre><code>sudo apt-get install python3 python3-pip virtualenvwrapper
</code></pre>

<p>Create a Python3 based virtual environment. Optionally enable <code>--system-site-packages</code> flag.</p>

<pre><code>mkvirtualenv -p /usr/bin/python3 &lt;venv-name&gt;
</code></pre>

<p>Set into the virtual environment.</p>

<pre><code>workon &lt;venv-name&gt;
</code></pre>

<p>Install other requirements using <code>pip</code> package manager.</p>

<pre><code>pip install -r requirements.txt
pip install &lt;package_name&gt;
</code></pre>

<hr>

<p>When working on multiple python projects simultaneously it is usually recommended to install common packages like <code>Django</code> globally and then reuse them in virtualenvs.</p>

<p>Using this technique saves a lot of time spent on fetching packages and installing them, apart from consuming minimal disk space and network bandwidth.</p>

<pre><code>sudo -H pip3 -v install Django
mkvirtualenv -p $(which python3) --system-site-packages &lt;venv-name&gt;
</code></pre>
"
3242895|"<p>You can ask any object which module it came from by looking at its __ module__ property. This is useful, for example, if you're experimenting at the command line and have imported a lot of things.</p>

<p>Along the same lines, you can ask a module where it came from by looking at its __ file__ property.  This is useful when debugging path issues.</p>
"
1952485|"<p>This isn't sufficient: the object returned by <code>__iter__</code> must implement the iteration protocol (i.e. <code>next</code> method). See the relevant section in the <a href=""http://docs.python.org/library/stdtypes.html#iterator-types"" rel=""noreferrer"">documentation</a>.</p>

<p>In Python, a good practice is to ""try and see"" instead of ""checking"".</p>
"
10973829|"<p>Simplifying a bit, you can imagine <code>map()</code> doing something like this:</p>

<pre><code>def mymap(func, lst):
    result = []
    for e in lst:
        result.append(func(e))
    return result
</code></pre>

<p>As you can see, it takes a function and a list, and returns a new list with the result of applying the function to each of the elements in the input list. I said ""simplifying a bit"" because in reality <code>map()</code> can process <em>more than one</em> iterable:</p>

<blockquote>
  <p>If additional iterable arguments are passed, function must take that many arguments and is applied to the items from all iterables in parallel. If one iterable is shorter than another it is assumed to be extended with None items.</p>
</blockquote>

<p>For the second part in the question: What role does this play in making a Cartesian product? well, <code>map()</code> <em>could</em> be used for generating the cartesian product of a list like this:</p>

<pre><code>lst = [1, 2, 3, 4, 5]

from operator import add
reduce(add, map(lambda i: map(lambda j: (i, j), lst), lst))
</code></pre>

<p>... But to tell the truth, using <a href=""http://docs.python.org/library/itertools.html#itertools.product"" rel=""noreferrer""><code>product()</code></a> is a much simpler and natural way to solve the problem:</p>

<pre><code>from itertools import product
list(product(lst, lst))
</code></pre>

<p>Either way, the result is the cartesian product of <code>lst</code> as defined above:</p>

<pre><code>[(1, 1), (1, 2), (1, 3), (1, 4), (1, 5),
 (2, 1), (2, 2), (2, 3), (2, 4), (2, 5),
 (3, 1), (3, 2), (3, 3), (3, 4), (3, 5),
 (4, 1), (4, 2), (4, 3), (4, 4), (4, 5),
 (5, 1), (5, 2), (5, 3), (5, 4), (5, 5)]
</code></pre>
"
39079453|"<h2>For deleting files:</h2>

<p>You can use <a href=""https://docs.python.org/library/os.html#os.unlink""><code>unlink</code></a> or <a href=""https://docs.python.org/library/os.html#os.remove""><code>remove</code></a>. </p>

<pre><code>os.unlink(path, *, dir_fd=None)
</code></pre>

<p>Or</p>

<pre><code>os.remove(path, *, dir_fd=None)
</code></pre>

<p>This functions removes (deletes) the file path. If path is a directory, <a href=""https://docs.python.org/library/exceptions.html#OSError""><code>OSError</code></a> is raised.</p>

<p>In Python 2, if the path does not exist, <code>OSError</code> with [Errno 2] (<code>ENOENT</code>) is raised. In Python 3, <code>FileNotFoundError</code> with [Errno 2] (<code>ENOENT</code>) is raised. In Python 3, because <code>FileNotFoundError</code> is a subclass of <code>OSError</code>, catching the latter will catch the former.</p>

<h2>For deleting folders:</h2>

<pre><code>os.rmdir(path, *, dir_fd=None)
</code></pre>

<p><a href=""https://docs.python.org/library/os.html#os.rmdir""><code>rmdir</code></a> Remove (delete) the directory path. Only works when the directory is empty, otherwise, <a href=""https://docs.python.org/library/exceptions.html#OSError"">OSError</a> is raised. 
In order to remove whole directory trees, <a href=""https://docs.python.org/library/shutil.html#shutil.rmtree""><code>shutil.rmtree()</code></a> can be used.</p>

<pre><code>shutil.rmtree(path, ignore_errors=False, onerror=None)
</code></pre>

<p><code>shutil.rmtree</code> Delete an entire directory tree. Path must point to a directory (but not a symbolic link to a directory). </p>

<p>If ignore_errors is true, errors resulting from failed removals will be ignored and if false or omitted, such errors are handled by calling a handler specified by onerror or, if that is omitted, they raise an exception.</p>

<p>See also:</p>

<pre><code>os.removedirs(name)
</code></pre>

<p><a href=""https://docs.python.org/library/os.html#os.removedirs""><code>os.removedirs(name)</code></a> Remove directories recursively. Works like rmdir() except that, if the leaf directory is successfully removed, removedirs() tries to successively remove every parent directory mentioned in path until an error is raised (which is ignored, because it generally means that a parent directory is not empty). </p>

<p>For example, os.removedirs('foo/bar/baz') will first remove the directory 'foo/bar/baz', and then remove 'foo/bar' and 'foo' if they are empty. </p>
"
38778859|"<p>Yet another functional solution for Python 2:</p>

<pre><code>from functools import partial

map(partial(map, int), T1)
</code></pre>

<p>Python 3 will be a little bit messy though:</p>

<pre><code>list(map(list, map(partial(map, int), T1)))
</code></pre>
"
18296313|"<p>I recommend looking at <a href=""http://docopt.org/"" rel=""nofollow"">docopt</a> as a simple alternative to these others.</p>

<p>docopt is a new project that works by parsing your --help usage message rather than requiring you to implement everything yourself. You just have to put your usage message in the POSIX format.</p>
"
1035419|"<p>If the file is not too big that holding it in memory is a problem:</p>

<pre><code>bytes_read = open(""filename"", ""rb"").read()
for b in bytes_read:
    process_byte(b)
</code></pre>

<p>where process_byte represents some operation you want to perform on the passed-in byte.</p>

<p>If you want to process a chunk at a time:</p>

<pre><code>file = open(""filename"", ""rb"")
try:
    bytes_read = file.read(CHUNKSIZE)
    while bytes_read:
        for b in bytes_read:
            process_byte(b)
        bytes_read = file.read(CHUNKSIZE)
finally:
    file.close()
</code></pre>
"
15441162|"<p>I like Spyder, it has many tools, such as profiling, intelligent indentation helper and a good autocompletion support</p>

<p><a href=""https://code.google.com/p/spyderlib/"" rel=""nofollow"">https://code.google.com/p/spyderlib/</a></p>
"
1835599|"<p>Generally speaking, the fact that a function which iterates over an object works on strings as well as tuples and lists is more feature than bug.  You certainly <em>can</em> use <code>isinstance</code> or duck typing to check an argument, but why should you?</p>

<p>That sounds like a rhetorical question, but it isn't.  The answer to ""why should I check the argument's type?"" is probably going to suggest a solution to the real problem, not the perceived problem.  Why is it a bug when a string is passed to the function?  Also:  if it's a bug when a string is passed to this function, is it also a bug if some other non-list/tuple iterable is passed to it?  Why, or why not?</p>

<p>I think that the most common answer to the question is likely to be that developers who write <code>f(""abc"")</code> are expecting the function to behave as though they'd written <code>f([""abc""])</code>.  There are probably circumstances where it makes more sense to protect developers from themselves than it does to support the use case of iterating across the characters in a string.  But I'd think long and hard about it first.</p>
"
4847186|"<p>The type module also exists if you are checking more than ints and strings. 
<a href=""http://docs.python.org/library/types.html"" rel=""noreferrer"">http://docs.python.org/library/types.html</a></p>
"
85489|"<pre><code>clock() -&gt; floating point number

Return the CPU time or real time since the start of the process or since
the first call to clock().  This has as much precision as the system
records.

time() -&gt; floating point number

Return the current time in seconds since the Epoch.
Fractions of a second may be present if the system clock provides them.
</code></pre>

<p>Usually time() is more precise, because operating systems do not store the process running time with the precision they store the system time (ie, actual time)</p>
"
22893823|"<p>You can try this code</p>

<pre><code>import glob
import os
filenames_without_extension = [os.path.basename(c).split('.')[0:1][0] for c in glob.glob('your/files/dir/*.txt')]
filenames_with_extension = [os.path.basename(c) for c in glob.glob('your/files/dir/*.txt')]
</code></pre>
"
1207634|"<p>Well, if you're willing/ready to switch to Python 3 (which you may not be due to the backwards incompatibility with some Python 2 code), you don't have to do any converting; all text in Python 3 is represented with Unicode strings, which also means that there's no more usage of the <code>u'&lt;text&gt;'</code> syntax. You also have what are, in effect, strings of bytes, which are used to represent data (which may be an encoded string).</p>

<p><a href=""http://docs.python.org/3.1/whatsnew/3.0.html#text-vs-data-instead-of-unicode-vs-8-bit"" rel=""nofollow noreferrer"">http://docs.python.org/3.1/whatsnew/3.0.html#text-vs-data-instead-of-unicode-vs-8-bit</a></p>

<p>(Of course, if you're currently using Python 3, then the problem is likely something to do with how you're attempting to save the text to a file.)</p>
"
13485766|"<p>It's difficult to make <code>del df.column_name</code> work simply as the result of syntactic limitations in Python. <code>del df[name]</code> gets translated to <code>df.__delitem__(name)</code> under the covers by Python</p>
"
438845|"<p><code>reload(module)</code>, but only if it's completely stand-alone. If anything else has a reference to the module (or any object belonging to the module), then you'll get subtle and curious errors caused by the old code hanging around longer than you expected, and things like <code>isinstance</code> not working across different versions of the same code.</p>

<p>If you have one-way dependencies, you must also reload all modules that depend on the the reloaded module to get rid of all the references to the old code. And then reload modules that depend on the reloaded modules, recursively.</p>

<p>If you have circular dependencies, which is very common for example when you are dealing with reloading a package, you must unload all the modules in the group in one go. You can't do this with <code>reload()</code> because it will re-import each module before its dependencies have been refreshed, allowing old references to creep into new modules.</p>

<p>The only way to do it in this case is to hack <code>sys.modules</code>, which is kind of unsupported. You'd have to go through and delete each <code>sys.modules</code> entry you wanted to be reloaded on next import, and also delete entries whose values are <code>None</code> to deal with an implementation issue to do with caching failed relative imports. It's not terribly nice but as long as you have a fully self-contained set of dependencies that doesn't leave references outside its codebase, it's workable.</p>

<p>It's probably best to restart the server. :-)</p>
"
1010597|"<p>There is also <a href=""https://docs.python.org/library/argparse.html"" rel=""noreferrer""><code>argparse</code> stdlib module</a> (an ""impovement"" on stdlib's <code>optparse</code> module). Example from <a href=""https://docs.python.org/howto/argparse.html"" rel=""noreferrer"">the introduction to argparse</a>:</p>

<pre><code># script.py
import argparse

if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument(
        'integers', metavar='int', type=int, choices=range(10),
         nargs='+', help='an integer in the range 0..9')
    parser.add_argument(
        '--sum', dest='accumulate', action='store_const', const=sum,
        default=max, help='sum the integers (default: find the max)')

    args = parser.parse_args()
    print(args.accumulate(args.integers))
</code></pre>

<p>Usage:</p>

<pre><code>$ script.py 1 2 3 4
4

$ script.py --sum 1 2 3 4
10
</code></pre>
"
1019572|"<p>One line, probably pretty fast:</p>

<pre><code>num_lines = sum(1 for line in open('myfile.txt'))
</code></pre>
"
2294513|"<pre><code>string.find(character)  
string.index(character)  
</code></pre>

<p>Perhaps you'd like to have a look at <a href=""http://docs.python.org/library/stdtypes.html#string-methods"" rel=""noreferrer"">the documentation</a> to find out what the difference between the two is.</p>
"
613228|"<p>Dicts can't be sorted, but you can build a sorted list from them.</p>

<p>A sorted list of dict values:</p>

<pre><code>sorted(d.values())
</code></pre>

<p>A list of (key, value) pairs, sorted by value:</p>

<pre><code>from operator import itemgetter
sorted(d.items(), key=itemgetter(1))
</code></pre>
"
7817348|"<p>Use <strong>ValueSortedDict</strong> from <a href=""http://pypi.python.org/pypi/dicts"" rel=""noreferrer"">dicts</a>:</p>

<pre><code>from dicts.sorteddict import ValueSortedDict
d = {1: 2, 3: 4, 4:3, 2:1, 0:0}
sorted_dict = ValueSortedDict(d)
print sorted_dict.items() 

[(0, 0), (2, 1), (1, 2), (4, 3), (3, 4)]
</code></pre>
"
227466|"<p>You are looking for:</p>

<pre><code>ord()
</code></pre>
"
7838845|"<p>A nice profiling module is the line_profiler (called using the script kernprof.py).  It can be downloaded <a href=""http://packages.python.org/line_profiler/"" rel=""noreferrer"">here</a>.</p>

<p>My understanding is that cProfile only gives information about total time spent in each function.  So individual lines of code are not timed.  This is an issue in scientific computing since often one single line can take a lot of time.  Also, as I remember, cProfile didn't catch the time I was spending in say numpy.dot.</p>
"
14833803|"<p><strong>To RUN</strong> press <kbd>Ctrl</kbd><kbd>B</kbd> (answer by <a href=""https://stackoverflow.com/a/8552149/985454"">matiit</a>)</p>

<p>But when <kbd>Ctrl</kbd><kbd>B</kbd> <strong>does not work</strong>, Sublime Text probably can't find the Python Interpreter. When trying to run your program, see the log and find the reference to Python in path.</p>

<pre><code>[cmd:  [u'python', u'-u', u'C:\\scripts\\test.py']]
[path: ...;C:\Python27 32bit;...]
</code></pre>

<p>The point is that it tries to run python via command line, the cmd looks like:</p>

<pre><code>python -u C:\scripts\test.py
</code></pre>

<p>If you can't run python from cmd, Sublime Text can't too.<br>
(Try it yourself in cmd, type python in it and run it, python commandline should appear)</p>

<h1>SOLUTION</h1>

<p>You can either change the Sublime Text build formula or the System <code>%PATH%</code>.  </p>

<ul>
<li><p>To set your <code>%PATH%</code>:<br>
*<em>You will need to restart your editor to load new <code>%PATH%</code></em></p>

<ul>
<li><p>Run Command Line* and enter this command: <em>*needs to be run as administrator</em><br>
<code>SETX /M PATH ""%PATH%;&lt;python_folder&gt;""</code><br>
for example: <code>SETX /M PATH ""%PATH%;C:\Python27;C:\Python27\Scripts""</code>  </p></li>
<li><p><strong>OR</strong> manually: (preferable)<br>
Add <code>;C:\Python27;C:\Python27\Scripts</code> at the end of the string.
<img src=""https://i.stack.imgur.com/7J5mQ.png"" alt=""Setting Path in Win7"">  </p></li>
</ul></li>
<li><p>To set the interpreter's path without messing with System <code>%PATH%</code> see this answer by <a href=""https://stackoverflow.com/a/9607682/985454"">ppy</a>.</p></li>
</ul>
"
28811205|"<p>Simply call del d['key'].</p>

<p>However, in production, it is always a good practice to check if 'key' exists in d.</p>

<pre><code>if 'key' in d:
    del d['key']
</code></pre>
"
34971949|"<pre><code>import os;
print os.getcwd(); # Prints the working directory
</code></pre>

<p>To set the working directory:</p>

<pre><code>os.chdir('c:\\Users\uname\desktop\python') # Provide the path here
</code></pre>
"
29289118|"<pre><code>with open(fname) as fo:
        data=fo.read().replace('\n', ' ').replace (',', ' ')
</code></pre>

<p>This should answer your question. The replace function will act as delimiter to strip the file.</p>
"
23102554|"<p>Lets Say I h'v a Dictionary D with elements below. To sort just use key argument in sorted to pass custom function as below</p>

<pre><code>D = {'eggs': 3, 'ham': 1, 'spam': 2}

def get_count(tuple):
    return tuple[1]

sorted(D.items(), key = get_count, reverse=True)
or
sorted(D.items(), key = lambda x: x[1], reverse=True)  avoiding get_count function call
</code></pre>

<p><a href=""https://wiki.python.org/moin/HowTo/Sorting/#Key_Functions"" rel=""nofollow"">https://wiki.python.org/moin/HowTo/Sorting/#Key_Functions</a></p>
"
89267|"<p><code>os.system</code> has been superseded by the <code>subprocess</code> module. Use subproccess instead.</p>
"
2294502|"<p>There are two string methods for this, <code>find</code> and <code>index</code>.</p>

<p>Example:</p>

<pre><code>&gt;&gt;&gt; myString = ""Position of a character""
&gt;&gt;&gt; myString.index('s')
2
</code></pre>

<p>The difference is that <code>find</code> returns <code>-1</code> when what you're looking for isn't found. <code>index</code> throws an exception.</p>

<blockquote>
  <p>Function <code>str.find(sub[, start[, end]])</code><br>
  Return the lowest index in the string where substring sub is found, such that sub is contained in the range <code>[start, end]</code>. Optional arguments start and end are interpreted as in slice notation. Return <code>-1</code> if sub is not found. </p>
</blockquote>

<p>And:</p>

<blockquote>
  <p>Function <code>str.index(sub[, start[, end]])</code><br>
  Like <code>find()</code>, but <code>raise ValueError</code> when the substring is not found.</p>
</blockquote>
"
28867664|"<p>I usually use: </p>

<pre class=""lang-py prettyprint-override""><code>if ((cond1 == 'val1' and cond2 == 'val2' and
     cond3 == 'val3' and cond4 == 'val4')):
    do_something()
</code></pre>
"
